## Environment for the static exam configuration.
#' @importFrom digest digest2int
#' @include state_frame.R
#' @include exercise_evaluators.R
#' @include storage_provider.R
.exam_configuration <- state_frame(list(
  points_format = function (pts) {
    if (pts <= 0) {
      return(get_status_message("exercise")$points$zero)
    } else if (pts == 1) {
      return(get_status_message("exercise")$points$one)
    } else {
      return(sprintf(get_status_message("exercise")$points$many, pts))
    }
  },
  data_provider = function (...) list(),
  exercise_data_provider = function (...) list(),
  auth_provider = function (...) {
    seed <- sample.int(.Machine$integer.max, 1L)
    return(list(user_id = paste('dummy',  format(Sys.time(), '%Y%m%dT%H%M%S%z'), as.hexmode(seed), sep = '_')))
  },
  exercise_evaluator = future_evaluator,
  storage_provider = .void_storage_provider(),
  seed_attempt = function (user, prev_attempts) {
    # by default, every attempt gets the same seed!
    digest2int(user$user_id)
  },
  feedback_urls_printed = character(0L)
))

#' Exam Configuration
#'
#' Set the global exam configuration. Must be called from the server context
#' (i.e., in an R code chunk with `context="server"`).
#'
#' Only non-missing options are set, the others are kept at their previous values.
#'
#' @param auth_provider an authentication provider function to identify a user.
#'   See [authentication providers][authentication_provider] for details.
#'   If `NULL`, the authentication provider will be reset to a dummy provider which generates a random user id for
#'   every request.
#' @param storage_provider a storage provider list of functions for saving/retrieving section data.
#'   See [storage providers][storage_provider] for details.
#'   If `NULL`, the authentication provider will be reset to a dummy provider which does not safe any section
#'   data.
#' @param exercise_evaluator a function which creates an exercise evaluator. See
#'   [exercise evaluators][exercise_evaluator] for details.
#' @param seed_attempt a function to generate the seed for the random number generator used in a single attempt.
#'   By default every user gets their unique seed which does not change between attempts.
#'   See _Seeding function_ for more details.
#' @param exercise_data_provider a data provider function which generates the user-specific (e.g., randomized) data
#'   for *all* exercise chunks. Similar to `data_provider`, but gets an argument `chunk_label` instead of `section`.
#'   See the section on _Exercise Data Providers_ below.
#'   Note that exercise chunks have access *only* to the data returned by this data provider.
#'   The enclosing environment of the returned environment (or list) will be set to the empty environment, [emptyenv()].
#' @param cache_data cache the data generated by the exercise data provider (for `exam_config()`) or the data provider
#'   for (`data_provider()`) in the Shiny session.
#'   This makes sense if generating the data takes a while, but is only small in size.
#'
#' @section Data provider:
#' Each section and question is rendered in a _sterile_ environment, containing only the data returned by the data
#' provider. This data provider is called every time a section is rendered and should return a list or environment
#' with all the objects required to render the section. This includes the user-specific randomized values.
#' The function should not set the seed itself, as it is set before the data provider is invoked.
#'
#' The data provider is a function taking arguments
#'
#' \describe{
#' \item{`section`}{the identifier of the current section or `TRUE` when data for all sections is requested.}
#' \item{`attempt`}{the _attempt object_ containing information about the current attempt, or `NULL` if called
#'   when pre-rendering the exam.}
#' \item{`session`}{the Shiny session object or `NULL` if called when pre-rendering the exam.}
#' \item{`...`}{further arguments for future additions}
#' }
#'
#' The data provider function returns a list or an environment containing all objects required to render the sections.
#' Internally, the markdown code for each section is rendered with [rmarkdown::render()] in the environment returned
#' by the data provider.
#'
#' **Warning:**
#' To ensure the answers can be reproduced, the exercise data provider must *always* return the same values for
#' a given attempt.
#' The data provider **must not** use the `attempt$user$user_id` information for randomization and should in general
#' not change the seed. When grading the `user_id` field may not be the same as for the exam itself!
#'
#' @section Exercise Data Providers:
#' The setup and user code of an exercise is run in a separate environment, possibly in a different R process.
#' This environment consists only of the objects in the list (or environment) returned by the exercise data provider.
#' The function should not set the seed itself, as it is set before the data provider is invoked.
#' The exercise data provider is run in the server R process and is called with the following arguments:
#'
#' \describe{
#' \item{`label`}{the exercise chunk label}
#' \item{`attempt`}{the attempt object as described in the _attempt object_ section containing information about
#'                  the current attempt (or `NULL`, see below).}
#' \item{`session`}{the Shiny session object or `NULL` for building the auto-completion (see below).}
#' \item{`...`}{further arguments for future additions}
#' }
#'
#' If the exercise data provider returns an environment, the enclosing environment will be set to the
#' empty environment, [emptyenv()].
#'
#' The exercise data provider is called once when the Shiny server starts with `attempt=NULL` and `session=NULL` to
#' ensure auto-completion knows about all available objects.
#'
#' **Warning:**
#' To ensure the answers can be reproduced, the exercise data provider must *always* return the same values for
#' a given attempt & exercise!
#' The data provider **must not** use the `attempt$user$user_id` field for randomization, but rely on the seed which
#' is already set. When grading the `user_id` field may not be the same as for the exam itself!
#'
#' @section Seeding function:
#' For more fine-grained control over the random seed used for an attempt, a seeding function may optionally be provided
#' as `seed_attempt`.
#' This function is called with the following arguments
#' \describe{
#' \item{`user`}{a user object as returned by the authentication provider.}
#' \item{`previous_attempts`}{a list of all previous attempts (see the section on the attempt object). The list does
#'                            not follow any particular order.}
#' \item{`...`}{further arguments for future additions}
#' }
#'
#' The seeding function is useful, for example, if a group of users should get the same seed, or if a user should
#' get the same seed for multiple attempts.
#'
#' The following seeding function, for example, gives the same seed for all users whose id starts with the same letter.
#' The seed changes with the attempt, but all users in a group will get the same seed for their 2nd, 3rd, etc, attempt.
#' ```
#' seeding_function <- function (user, previous_attempts, ...) {
#'   group <- substr(user$user_id, 1, 1)
#'   # take the number of attempts into account
#'   digest::digest2int(paste(group, length(previous_attempts)))
#' }
#' ```
#'
#' The next seeding function gives a different seed for every user, but gives the same seed for every 5 attempts.
#' ```
#' seeding_function <- function (user, previous_attempts, ...) {
#'   blocks_of_5 <- floor(length(previous_attempts) / 5)
#'   digest::digest2int(paste(user$user_id, blocks_of_5))
#' }
#' ```
#'
#' @section Attempt object:
#' Some functions receive one or more attempt objects. An attempt object is a list with the following elements:
#'
#' \describe{
#' \item{`id`}{a character string (UUID) uniquely identifying the attempt.}
#' \item{`user`}{a user object as returned by the authentication provider.}
#' \item{`seed`}{an integer associated with the attempt for initializing the random number generator.}
#' \item{`started_at`}{the UTC time the attempt was first started (as [POSIXct][DateTimeClasses]).}
#' }
#'
#' @examples
#' # Use the RStudio Connect user and assign a fixed seed for all attempts
#' function (shiny_session) {
#'   user_id <- shiny_session$user
#'   return(list(user_id = user_id, seed = digest::digest2int(shiny_session$user)))
#' }
#' # Use the RStudio Connect user and assign the same seed for all users with the same first letter.
#' function (shiny_session) {
#'   user_id <- shiny_session$user
#'   return(list(user_id = user_id,
#'               seed = function (user, prev_attempts, ...) {
#'
#'               }))
#' }
#'
#' @importFrom rlang missing_arg abort is_function
#' @importFrom knitr opts_current
#' @family exam configuration
#' @export
exam_config_server_start <- function (auth_provider, storage_provider, exercise_data_provider,
                                      exercise_evaluator, seed_attempt, cache_data = FALSE) {
  if (!is_knitr_context('server-start')) {
    abort("`exam_config_server_start()` must be called in a context='server-start' chunk.")
  }

  if (!is_missing(exercise_data_provider)) {
    .exam_configuration$set(exercise_data_provider = cached_data_provider(exercise_data_provider, isTRUE(cache_data)))
  }

  if (!missing(auth_provider)) {
    if (is.list(auth_provider) && inherits(auth_provider, 'ui_authentication_provider')) {
      .exam_configuration$set(login_ui = auth_provider[c('ui', 'callback')])
      auth_provider <- auth_provider$auth
    }
  }

  .exam_configuration$set(
    auth_provider = auth_provider,
    storage_provider = storage_provider,
    exercise_evaluator = exercise_evaluator,
    seed_attempt = seed_attempt)
}

#' @rdname exam_config_server_start
#'
#' @details
#' `exam_config()` is **deprecated** in favor of the function `exam_config_server_start()`.
#'
#' @export
#'
#' @importFrom lifecycle deprecate_warn
exam_config <- function (...) {
  deprecate_warn("0.4.0", "exam_config()", "exam_config_server_start()")
  exam_config_server_start(...)
}

#' @rdname exam_config_server_start
#'
#' @param fun a data provider function which generates the user-specific (e.g., randomized) data for
#'   the sections. See section _Data provider_ for details.
#' @importFrom knitr opts_knit
#' @importFrom withr with_preserve_seed
#' @importFrom rlang abort
#' @export
data_provider <- function (fun, cache_data = FALSE) {
  if (!is_knitr_context('setup')) {
    abort("`data_provider()` must be called in the setup chunk.")
  }

  if (isTRUE(getOption('knitr.in.progress')) && isTRUE(opts_knit$get('examinr.initial_pass'))) {
    # In the initial rendering step, make the data from the data provider available to the document.
    data_env <- with_preserve_seed(fun(section = TRUE, attempt = NULL, session = NULL))

    if (is.environment(data_env)) {
      data_env <- as.list.environment(data_env, all.names = TRUE)
    } else if (!is.list(data_env)) {
      abort("Data provider returns invalid environment.")
    }

    env_name <- random_ui_id('examinr_data_provider_env')
    knit_meta_add(list(structure(env_name, class = 'examinr_data_provider_env')))

    # Attach data returned by the data provider to the search path for knitting.
    # This will be removed after knitting in the post_knit handler
    attach(data_env, name = env_name, warn.conflicts = FALSE)
  } else {
    # Set the data provider for the exam configuration.
    .exam_configuration$set(data_provider = cached_data_provider(fun, isTRUE(cache_data)))
  }
}

#' @rdname exam_config_server_start
#'
#' @param points_format formats for showing the number of points per question. The first format
#'   is for plural, the second for singular. If only a single format is given, it is used for both plural and
#'   singular. Can also be a function which receives the number of points and should return the label to display.
#'   The default is `points_format = c('%d point', '%d points')`.
#' @param data_provider a data provider function which generates the user-specific (e.g., randomized) data for
#'   the sections. See section _Data provider_ for details.
#'
#' @importFrom knitr opts_knit
#' @importFrom withr with_preserve_seed
#' @importFrom rlang abort missing_arg is_function
#' @export
exam_document_setup <- function (points_format, data_provider, cache_data = FALSE) {
  if (!is_knitr_context('setup')) {
    abort("`exam_document_setup()` must be called in the setup chunk.")
  }

  if (!missing(points_format)) {
    points_format_fun <- if (is_function(points_format)) {
      points_format
    } else {
      function (pts) {
        if (pts == 1) {
          return(sprintf(points_format[[1L]], pts))
        } else if (length(points_format) > 1L) {
          return(sprintf(points_format[[2L]], pts))
        } else {
          return(sprintf(points_format, pts))
        }
      }
    }
    .exam_configuration$set(points_format = points_format_fun)
  }

  if (!missing(data_provider)) {
    if (isTRUE(getOption('knitr.in.progress')) && isTRUE(opts_knit$get('examinr.initial_pass'))) {
      # In the initial rendering step, make the data from the data provider available to the document.
      data_env <- with_preserve_seed(data_provider(section = TRUE, attempt = NULL, session = NULL))

      if (is.environment(data_env)) {
        data_env <- as.list.environment(data_env, all.names = TRUE)
      } else if (!is.list(data_env)) {
        abort("Data provider returns invalid environment.")
      }

      env_name <- random_ui_id('examinr_data_provider_env')
      knit_meta_add(list(structure(env_name, class = 'examinr_data_provider_env')))

      # Attach data returned by the data provider to the search path for knitting.
      # This will be removed after knitting in the post_knit handler
      attach(data_env, name = env_name, warn.conflicts = FALSE)
    } else {
      # Set the data provider for the exam configuration.
      .exam_configuration$set(data_provider = cached_data_provider(data_provider, isTRUE(cache_data)))
    }
  }
}

#' @rdname exam_config_server_start
#'
#' @details
#' `exam_setup()` is **deprecated** in favor of the function `exam_document_setup()`.
#'
#' @export
#'
#' @importFrom lifecycle deprecate_warn
exam_setup <- function (...) {
  deprecate_warn("0.4.0", "exam_setup()", "exam_document_setup()")
  exam_document_setup(...)
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_finish_attempt <- function (attempt_id, finished_at) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(finished_at)
    res <- .exam_configuration$get('storage_provider')$finish_attempt(attempt_id, finished_at)
    if (!isTRUE(res)) {
      stop("storage provider had an error")
    }
    return(TRUE)
  }, error = function (e) {
    warn(sprintf("Cannot finish attempt %s: %s", attempt_id, cnd_message(e)))
    return(FALSE)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_create_attempt <- function (user, exam_id, exam_version, seed, started_at) {
  tryCatch({
    # force evaluation of arguments
    force(user)
    force(exam_id)
    force(exam_version)
    force(seed)
    force(started_at)
    res <- .exam_configuration$get('storage_provider')$create_attempt(user, exam_id, exam_version, seed, started_at)
    if (is.null(res)) {
      stop("storage provider had an error")
    }
    return(res)
  }, error = function (e) {
    warn(sprintf("Cannot create new attempt for user %s: %s", user$user_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_grade_attempt <- function (attempt_id, points) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(points)
    res <- .exam_configuration$get('storage_provider')$grade_attempt(attempt_id, points)
    if (!isTRUE(res)) {
      stop("storage provider had an error")
    }
    return(TRUE)
  }, error = function (e) {
    warn(sprintf("Cannot grade attempt %s: %s", attempt_id, cnd_message(e)))
    return(FALSE)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_get_attempts <- function (user, exam_id, exam_version) {
  tryCatch({
    # force evaluation of arguments
    force(user)
    force(exam_id)
    force(exam_version)
    .exam_configuration$get('storage_provider')$get_attempts(user, exam_id, exam_version)
  }, error = function (e) {
    warn(sprintf("Cannot get attempts for user %s: %s", user$user_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_save_section_data <- function (attempt_id, section, section_data) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(section)
    force(section_data)
    res <- .exam_configuration$get('storage_provider')$save_section_data(attempt_id, section, section_data)
    if (!isTRUE(res)) {
      stop("storage provider had an error")
    }
    return(TRUE)
  }, error = function (e) {
    warn(sprintf("Cannot save data for section %s of attempt %s: %s", section, attempt_id, cnd_message(e)))
    return(FALSE)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_get_section_data <- function (attempt_id, section) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(section)
    .exam_configuration$get('storage_provider')$get_section_data(attempt_id, section)
  }, error = function (e) {
    warn(sprintf("Cannot get data for section %s of attempt %s: %s", section, attempt_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_get_last_section <- function (attempt_id) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    .exam_configuration$get('storage_provider')$get_last_section(attempt_id)
  }, error = function (e) {
    warn(sprintf("Cannot get last section for attempt %s: %s", attempt_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured seed generator
#' @importFrom rlang abort cnd_message
seed_attempt <- function (user, prev_attempts) {
  tryCatch({
    seed <- .exam_configuration$get('seed_attempt')(user, prev_attempts)
    if (!is.integer(seed)) {
      stop("generated seed is not an integer.")
    }
    return(seed)
  }, error = function (e) {
    warn(paste("Cannot determine seed for new attempt:", cnd_message(e)))
    # Create a seed from the user's ID
    return(digest2int(user$user_id))
  })
}

#' @importFrom shiny getDefaultReactiveDomain
#' @importFrom rlang warn abort
get_current_user <- function (session) {
  session_env <- get_session_env(session)
  if (is.null(session_env$user)) {
    # authenticate current user
    session_env$user <- withCallingHandlers({
      .exam_configuration$get('auth_provider')(session)
    }, error = function (e) {
      abort(paste("Cannot authenticate user:", cnd_message(e)))
    })
    if (!is.null(session_env$user) && !is.character(session_env$user$user_id)) {
      warn("User ID is of wrong type. Forcefully casting to character!")
      session_env$user$user_id <- as.character(session_env$user$user_id)
    }
  }
  return(session_env$user)
}

get_login_ui <- function () {
  .exam_configuration$get('login_ui')
}

format_points <- function (points) {
  if (is.null(points)) {
    return(NULL)
  }
  ptstr <- withCallingHandlers({
    points <- points[[1L]]
    if (points < 0) {
      abort("Points for questions and exercises must be non-negative.")
    }
    .exam_configuration$get('points_format')(points[[1L]])
  }, error = function (e) {
    abort("Cannot format points: ", cnd_message(e))
  })
  if (!is.character(ptstr) || length(ptstr) != 1L) {
    abort("Wrong points string returned from formatter.")
  }
  return(ptstr)
}

#' @importFrom digest digest
cached_data_provider <- function (fun, enabled) {
  if (enabled) {
    cache <- list()
    function (..., session) {
      hash <- digest(list(...))
      if (is.null(cache[[hash]])) {
        cache[[hash]] <- fun(...)
      }
      return(cache[[hash]])
    }
  } else {
    fun
  }
}

#' @importFrom rlang warn
#' @importFrom withr with_seed
get_rendering_env <- function (session) {
  attempt <- isolate(get_current_attempt(session))
  section <- isolate(get_current_section(session))
  section_name <- if (isTRUE(section)) { TRUE } else { section$name }
  with_seed(attempt$seed, {
    data_env <- isolate(.exam_configuration$get('data_provider')(section = section_name, attempt = attempt,
                                                                 session = session))
  })

  if (is.list(data_env)) {
    data_env <- list2env(data_env, parent = globalenv())
  } else if (is.environment(data_env)) {
    parent.env(data_env) <- globalenv()
  } else {
    warn("Data provider returns invalid environment.")
    data_env <- globalenv()
  }

  return(data_env)
}

#' @importFrom rlang warn
#' @importFrom withr with_seed
get_exercise_user_env <- function (exercise_label, session, attempt) {
  if (missing(attempt)) {
    attempt <- isolate(get_current_attempt(session))
  }

  with_seed(attempt$seed, {
    data_env <- isolate(.exam_configuration$get('exercise_data_provider')(label = exercise_label, attempt = attempt,
                                                                          session = session))
  })
  if (is.list(data_env)) {
    data_env <- list2env(data_env, parent = emptyenv())
  } else if (is.environment(data_env)) {
    parent.env(data_env) <- emptyenv()
  } else {
    warn("Exercise data provider returns invalid environment.")
    data_env <- emptyenv()
  }

  return(data_env)
}

#' @importFrom rlang abort cnd_message
setup_exercise_promise <- function (expr, envir, label, timeout) {
  withCallingHandlers({
    force(expr)
    force(envir)
    force(label)
    force(timeout)
    .exam_configuration$get('exercise_evaluator')(expr, envir, label, timeout)
  }, error = function (e) {
    abort(sprintf("Cannot setup exercise promise for exercise chunk %s: %s", label, cnd_message(e)))
  })
}

#' @importFrom rlang inform
signal_feedback_url <- function (url) {
  if (!isTRUE(url %in% .exam_configuration$get('feedback_urls_printed'))) {
    # cat("Exam feedback available under", url, "\n", file = stderr())
    inform(paste("Exam feedback available under", url))
    .exam_configuration$append(feedback_urls_printed = url)
  }
}
