## Environment for the static exam configuration.
#' @importFrom digest digest2int
#' @include state_frame.R
#' @include exercise_evaluators.R
#' @include storage_provider.R
.exam_configuration <- state_frame(list(
  points_format = function (pts) {
    if (pts == 1) {
      return('1 point')
    } else {
      return(sprintf('%d points', pts))
    }
  },
  data_provider = function (...) list(),
  exercise_data_provider = function (...) list(),
  auth_provider = function (...) {
    seed <- sample.int(.Machine$integer.max, 1L)
    return(list(user_id = paste('dummy',  format(Sys.time(), '%Y%m%dT%H%M%S%z'), as.hexmode(seed), sep = '_')))
  },
  exercise_evaluator = psock_evaluator,
  storage_provider = .void_storage_provider(),
  seed_attempt = function (user, prev_attempts) {
    # by default, every attempt gets the same seed!
    digest2int(user$user_id)
  }
))

#' Exam Configuration
#'
#' Set the global exam configuration. Must be called from the server context
#' (i.e., in an R code chunk with `context="server"`).
#'
#' Only non-missing options are set, the others are kept at their previous values.
#'
#' @param auth_provider an authentication provider function to identify a user.
#'   See [authentication providers][authentication_provider] for details.
#'   If `NULL`, the authentication provider will be reset to a dummy provider which generates a random user id for
#'   every request.
#' @param storage_provider a storage provider list of functions for saving/retrieving section data.
#'   See [storage providers][storage_provider] for details.
#'   If `NULL`, the authentication provider will be reset to a dummy provider which does not safe any section
#'   data.
#' @param exercise_evaluator a function which creates an exercise evaluator. See
#'   [exercise evaluators][exercise_evaluator] for details.
#' @param data_provider a data provider function which generates the user-specific (e.g., randomized) data for
#'   the sections. See section _Data provider_ for details.
#' @param exercise_data_provider a data provider function which generates the user-specific (e.g., randomized) data
#'   for *all* exercise chunks. Similar to `data_provider`, but gets an argument `chunk_label` instead of `section`.
#'   See the section on _Exercise Data Providers_ below.
#'   Note that exercise chunks have access *only* to the data returned by this data provider.
#'   The enclosing environment of the returned environment (or list) will be set to the empty environment, [emptyenv()].
#' @param cache_data cache the data generated by the data providers in `data_provider` and/or `exercise_data_provider`
#'   in the shiny session. This makes sense if generating the data takes a while, but is only small in size.
#' @param points_format formats for showing the number of points per question. The first format
#'   is for plural, the second for singular. If only a single format is given, it is used for both plural and
#'   singular. Can also be a function which receives the number of points and should return the label to display.
#'   The default is `points_format = c('%d point', '%d points')`.
#'
#' @section Data provider:
#' Each section is rendered in a _sterile_ environment, containing only the data returned by the data provider.
#' This data provider is called every time a section is rendered and should return a list or environment with all
#' the objects required to render the section. This includes the user-specific randomized values.
#'
#' The data provider is a function taking arguments
#'
#'
#' \describe{
#' \item{`attempt`}{the _attempt_ object containing information about the current attempt.}
#' \item{`section`}{the identifier of the current section}
#' \item{`...`}{further arguments for future additions}
#' }
#'
#' The data provider function returns a list or an environment containing all objects required to render the sections.
#' Internally, the markdown code for each section is rendered with [rmarkdown::render()] in the environment returned
#' by the data provider.
#'
#' **Warning:**
#' To ensure the answers can be reproduced, the exercise data provider must *always* return the same values for
#' a given attempt & exercise!
#' The data provider **must not** use the `attempt$user$user_id` field for randomization, but rely only on
#' `attempt$seed`. When grading the `user_id` field may not be the same as for the exam itself!
#'
#' @section Exercise Data Providers:
#' The setup and user code is run in a separate environment, possibly in a different R process.
#' This environment consists only of the objects in the list (or environment) returned by the exercise data provider.
#' The exercise data provider is run in the server R process and is called with the following arguments:
#'
#' \describe{
#' \item{`attempt`}{the attempt object as described in the _Attempt object_ section containing information about
#'                  the current attempt (or `NULL`, see below).}
#' \item{`label`}{the exercise chunk label}
#' \item{`...`}{further arguments for future additions}
#' }
#'
#' If the exercise data provider returns an environment, the enclosing environment will be set to the
#' empty environment, [emptyenv()].
#'
#' The exercise data provider is called once when the shiny server starts with `attempt=NULL`
#' to ensure auto-completion knows about all available objects.
#'
#' **Warning:**
#' To ensure the answers can be reproduced, the exercise data provider must *always* return the same values for
#' a given attempt & exercise!
#' The data provider **must not** use the `attempt$user$user_id` field for randomization, but rely only on
#' `attempt$seed`. When grading the `user_id` field may not be the same as for the exam itself!
#'
#' @section Seeding function:
#' For more fine-grained control over the random seed used for an attempt, a seeding function may optionally be provided
#' as `seed_attempt`.
#' This function is called with the following arguments
#' \describe{
#' \item{`user`}{a user object as returned by the authentication provider.}
#' \item{`previous_attempts`}{a list of all previous attempts (see the section on the attempt object). The list does
#'                            not follow any particular order.}
#' \item{`...`}{further arguments for future additions}
#' }
#'
#' The seeding function is useful, for example, if a group of users should get the same seed, or if a user should
#' get the same seed for multiple attempts.
#'
#' The following seeding function, for example, gives the same seed for all users whose id starts with the same letter.
#' The seed changes with the attempt, but all users in a group will get the same seed for their 2nd, 3rd, etc, attempt.
#' ```
#' seeding_function <- function (user, previous_attempts, ...) {
#'   group <- substr(user$user_id, 1, 1)
#'   # take the number of attempts into account
#'   digest::digest2int(paste(group, length(previous_attempts)))
#' }
#' ```
#'
#' The next seeding function gives a different seed for every user, but gives the same seed for every 5 attempts.
#' ```
#' seeding_function <- function (user, previous_attempts, ...) {
#'   blocks_of_5 <- floor(length(previous_attempts) / 5)
#'   digest::digest2int(paste(user$user_id, blocks_of_5))
#' }
#' ```
#'
#' @section Attempt object:
#' Some functions receive one or more attempt objects. An attempt object is a list with the following elements:
#'
#' \describe{
#' \item{`id`}{a character string (UUID) uniquely identifying the attempt.}
#' \item{`user`}{a user object as returned by the authentication provider.}
#' \item{`seed`}{an integer associated with the attempt for intializing the random number generator.}
#' \item{`started_at`}{the UTC time the attempt was first started (as [POSIXct][DateTimeClasses]).}
#' }
#'
#' @examples
#' # Use the RStudio Connect user and assign a fixed seed for all attempts
#' function (shiny_session) {
#'   user_id <- shiny_session$user
#'   return(list(user_id = user_id, seed = digest::digest2int(shiny_session$user)))
#' }
#' # Use the RStudio Connect user and assign the same seed for all users with the same first letter.
#' function (shiny_session) {
#'   user_id <- shiny_session$user
#'   return(list(user_id = user_id,
#'               seed = function (user, prev_attempts, ...) {
#'
#'               }))
#' }
#'
#' @importFrom rlang missing_arg abort
#' @importFrom knitr opts_current
#' @export
exam_config <- function (auth_provider, storage_provider, data_provider, exercise_data_provider,
                         exercise_evaluator, seed_attempt,
                         cache_data = c('no', 'both', 'data', 'exercise_data'), points_format) {
  if (!is_knitr_context('server-start')) {
    abort("`exam_config()` must be called in a context='server-start' chunk.")
  }

  cache_data <- match.arg(cache_data)

  points_format_fun <- missing_arg()
  if (!missing(points_format)) {
    points_format_fun <- function (pts) {
      if (pts == 1) {
        return(sprintf(points_format[[1L]], pts))
      } else if (length(points_format) > 1L) {
        return(sprintf(points_format[[2L]], pts))
      } else {
        return(sprintf(points_format, pts))
      }
    }
  }

  .exam_configuration$set(
    auth_provider = auth_provider,
    points_format = points_format_fun,
    storage_provider = storage_provider,
    exercise_evaluator = exercise_evaluator,
    seed_attempt = seed_attempt,
    data_provider = cached_data_provider(data_provider %||% .exam_configuration$get('data_provider'),
                                         cache_data %in% c('both', 'data')),
    exercise_data_provider = cached_data_provider(exercise_data_provider %||%
                                                    .exam_configuration$get('exercise_data_provider'),
                                                  cache_data %in% c('both', 'exercise_data')))
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_finish_attempt <- function (attempt_id, finished_at) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(finished_at)
    res <- .exam_configuration$get('storage_provider')$finish_attempt(attempt_id, finished_at)
    if (!isTRUE(res)) {
      stop("storage provider had an error")
    }
    return(TRUE)
  }, error = function (e) {
    warn(sprintf("Cannot finish attempt %s: %s", attempt_id, cnd_message(e)))
    return(FALSE)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_create_attempt <- function (user, exam_id, exam_version, seed, started_at) {
  tryCatch({
    # force evaluation of arguments
    force(user)
    force(exam_id)
    force(exam_version)
    force(seed)
    force(started_at)
    res <- .exam_configuration$get('storage_provider')$create_attempt(user, exam_id, exam_version, seed, started_at)
    if (is.null(res)) {
      stop("storage provider had an error")
    }
    return(res)
  }, error = function (e) {
    warn(sprintf("Cannot create new attempt for user %s: %s", user$user_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_grade_attempt <- function (attempt_id, points) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(points)
    res <- .exam_configuration$get('storage_provider')$grade_attempt(attempt_id, points)
    if (!isTRUE(res)) {
      stop("storage provider had an error")
    }
    return(TRUE)
  }, error = function (e) {
    warn(sprintf("Cannot grade attempt %s: %s", attempt_id, cnd_message(e)))
    return(FALSE)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_get_attempts <- function (user, exam_id, exam_version) {
  tryCatch({
    # force evaluation of arguments
    force(user)
    force(exam_id)
    force(exam_version)
    .exam_configuration$get('storage_provider')$get_attempts(user, exam_id, exam_version)
  }, error = function (e) {
    warn(sprintf("Cannot get attempts for user %s: %s", user$user_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_save_section_data <- function (attempt_id, section, section_data) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(section)
    force(section_data)
    res <- .exam_configuration$get('storage_provider')$save_section_data(attempt_id, section, section_data)
    if (!isTRUE(res)) {
      stop("storage provider had an error")
    }
    return(TRUE)
  }, error = function (e) {
    warn(sprintf("Cannot save data for section %s of attempt %s: %s", section, attempt_id, cnd_message(e)))
    return(FALSE)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_get_section_data <- function (attempt_id, section) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    force(section)
    .exam_configuration$get('storage_provider')$get_section_data(attempt_id, section)
  }, error = function (e) {
    warn(sprintf("Cannot get data for section %s of attempt %s: %s", section, attempt_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured storage provider
#' @importFrom rlang abort cnd_message
sp_get_last_section <- function (attempt_id) {
  tryCatch({
    # force evaluation of arguments
    force(attempt_id)
    .exam_configuration$get('storage_provider')$get_last_section(attempt_id)
  }, error = function (e) {
    warn(sprintf("Cannot get last section for attempt %s: %s", attempt_id, cnd_message(e)))
    return(NULL)
  })
}

## Safe calling of to the configured seed generator
#' @importFrom rlang abort cnd_message
seed_attempt <- function (user, prev_attempts) {
  tryCatch({
    seed <-  .exam_configuration$get('seed_attempt')(user, prev_attempts)
    if (!is.integer(seed)) {
      stop("generated seed is not an integer.")
    }
    return(seed)
  }, error = function (e) {
    warn(paste("Cannot determine seed for new attempt:", cnd_message(e)))
    # Create a seed from the user's ID
    return(digest2int(user$user_id))
  })
}

#' @importFrom shiny getDefaultReactiveDomain
#' @importFrom rlang warn abort
get_current_user <- function (session) {
  if (missing(session)) {
    session <- getDefaultReactiveDomain()
  }
  session_env <- get_session_env(session)
  if (is.null(session_env$user)) {
    # authenticate current user
    session_env$user <- tryCatch({
      .exam_configuration$get('auth_provider')(session)
    }, error = function (e) {
      abort(paste("Cannot authenticate user:", cnd_message(e)))
      return(NULL)
    })
    if (!is.null(session_env$user) && !is.character(session_env$user$user_id)) {
      warn("User ID is of wrong type. Forcefully casting to character!")
      session_env$user$user_id <- as.character(session_env$user$user_id)
    }
  }
  return(session_env$user)
}

format_points <- function (points) {
  if (is.null(points)) {
    return(NULL)
  }
  ptstr <- withCallingHandlers({
    points <- points[[1L]]
    if (points < 0) {
      abort("Points for questions and exercises must be non-negative.")
    }
    .exam_configuration$get('points_format')(points[[1L]])
  }, error = function (e) {
    abort("Cannot format points: ", cnd_message(e))
  })
  if (!is.character(ptstr) || length(ptstr) != 1L) {
    abort("Wrong points string returned from formatter.")
  }
  return(ptstr)
}

#' @importFrom digest digest
cached_data_provider <- function (fun, enabled) {
  if (enabled) {
    cache <- list()
    function (...) {
      hash <- digest(list(...))
      if (is.null(cache[[hash]])) {
        cache[[hash]] <- fun(...)
      }
      return(cache[[hash]])
    }
  } else {
    fun
  }
}

#' @importFrom rlang warn
get_rendering_env <- function (section, session) {
  # get a "random seed" to ensure data generation does not determine all other r code
  reset_seed <- sample.int(.Machine$integer.max, 1L)

  data_env <- .exam_configuration$get('data_provider')(get_current_attempt(session), section)
  if (is.list(data_env)) {
    data_env <- list2env(data_env, parent = globalenv())
  } else if (is.environment(data_env)) {
    parent.env(data_env) <- globalenv()
  } else {
    warn("Data provider returns invalid environment.")
    data_env <- globalenv()
  }

  # new use the previously generated "random seed".
  set.seed(reset_seed)

  return(data_env)
}

#' @importFrom rlang warn
#' @importFrom withr local_preserve_seed
get_exercise_user_env <- function (exercise_label, session, attempt) {
  local_preserve_seed()

  if (missing(attempt)) {
    attempt <- get_current_attempt(session)
  }

  data_env <- .exam_configuration$get('exercise_data_provider')(attempt, exercise_label)
  if (is.list(data_env)) {
    data_env <- list2env(data_env, parent = emptyenv())
  } else if (is.environment(data_env)) {
    parent.env(data_env) <- emptyenv()
  } else {
    warn("Exercise data provider returns invalid environment.")
    data_env <- emptyenv()
  }

  return(data_env)
}

#' @importFrom rlang abort cnd_message
setup_exercise_evaluator <- function (expr, envir, label, timelimit) {
  withCallingHandlers({
    force(expr)
    force(envir)
    force(label)
    force(timelimit)
    .exam_configuration$get('exercise_evaluator')(expr, envir, label, timelimit)
  }, error = function (e) {
    abort(sprintf("Cannot setup exercise evaluator for exercise chunk %s: %s", label, cnd_message(e)))
  })
}
