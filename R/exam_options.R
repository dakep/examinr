## Environment containing exam options
#' @include state_frame.R
#' @include exercise_evaluators.R
.exam_data <- state_frame(list(
  points_format = function (pts) {
    if (pts == 1) {
      return('1 point')
    } else {
      return(sprintf('%d points', pts))
    }
  },
  data_provider = function (...) list(),
  exercise_data_provider = function (...) list(),
  auth_provider = function (shiny_session) {
    seed <- sample.int(.Machine$integer.max, 1L)
    return(list(user_id = paste('dummy',  format(Sys.time(), '%Y%m%dT%H%M%S%z'), as.hexmode(seed), sep = '_'),
                seed = seed))
  },
  exercise_evaluator = psock_evaluator,
  # exercise_evaluator = local_evaluator,
  storage_provider = list(
    get_section_data = function (...) {
      return(NULL)
    },
    save_section_data = function (...) {
      return(FALSE)
    })
))

.sections_data <- state_frame(list(render = NULL, order = NULL, next_button_label = NULL, specific = list()))

#' Set Options for an Exam
#'
#' Set global exam options. Must be called from the server context (i.e., in an R code chunk with `context="server"`).
#'
#' Only non-missing options are set, the others are kept at their previous values.
#'
#' @param auth_provider an authentication provider function to identify a user.
#'   See [authentication providers][authentication_provider] for details.
#'   If `NULL`, the authentication provider will be reset to a dummy provider which generates a random user id for
#'   every request.
#' @param storage_provider a storage provider list of functions for saving/retrieving section data.
#'   See [storage providers][storage_provider] for details.
#'   If `NULL`, the authentication provider will be reset to a dummy provider which does not safe any section
#'   data.
#' @param exercise_evaluator a function which creates an exercise evaluator. See
#'   [exercise evaluators][exercise_evaluator] for details.
#' @param data_provider a data provider function which generates the user-specific (e.g., randomized) data for
#'   the sections. See section _Data provider_ for details.
#' @param exercise_data_provider a data provider function which generates the user-specific (e.g., randomized) data
#'   for *all* exercise chunks. Similar to `data_provider`, but gets an argument `chunk_label` instead of `section`.
#'   See the section on _Exercise Data Providers_ below.
#'   Note that exercise chunks have access *only* to the data returned by this data provider.
#'   The enclosing environment of the returned environment (or list) will be set to the empty environment, [emptyenv()].
#' @param cache_data cache the data generated by the data providers in `data_provider` and/or `exercise_data_provider`
#'   in the shiny session. This makes sense if generating the data takes a while, but is only small in size.
#' @param points_format formats for showing the number of points per question. The first format
#'   is for plural, the second for singular. If only a single format is given, it is used for both plural and
#'   singular. Can also be a function which receives the number of points and should return the label to display.
#'   The default is `points_format = c('%d point', '%d points')`.
#'
#'
#' @section Data provider:
#' Each section is rendered in a _sterile_ environment, containing only the data returned by the data provider.
#' This data provider is called every time a section is rendered and should return a list or environment with all
#' the objects required to render the section. This includes the user-specific randomized values.
#'
#' The data provider is a function taking arguments
#'
#' - `user`: the user object as returned by the authentication provider,
#' - `section`: the identifier of the current section,
#' - `...`: further arguments for future additions.
#'
#' The data provider function returns a list or an environment containing all objects required to render the sections.
#' Internally, the markdown code for each section is rendered with [rmarkdown::render()] in the environment returned
#' by the data provider.
#'
#' @section Exercise Data Providers:
#' The user code is run in a separate environment, possibly in a different R process.
#' This environment consists only of the objects in the list (or environment) returned by the exercise data provider.
#' The exercise data provider is run in the server R process and is called with the following arguments:
#'
#' - `user`: the user object as returned by the authentication provider (or the _auto-completion_ user, see below),
#' - `label`: the exercise chunk label,
#' - `...`: further arguments for future additions.
#'
#' If the exercise data provider returns an environment, the enclosing environment will be set to the
#' empty environment, [emptyenv()].
#'
#' The exercise data provider is called once when the shiny server starts with the _auto-completion_ user object
#' to ensure auto-completion knows about all available objects.
#' The exercise data provider can test if the given user is the _auto-completion_ user with the function
#' [`is_autocompletion_user()`]. This user only has the required properties as defined by
#' [authentication providers][authentication_provider].
#'
#' @importFrom rlang missing_arg abort
#' @export
exam_options <- function (auth_provider, storage_provider, data_provider, exercise_data_provider,
                          exercise_evaluator, cache_data = c('no', 'both', 'data', 'exercise_data'),
                          points_format) {
  if (isTRUE(getOption('knitr.in.progress')) && !isTRUE(opts_knit$get('context') == 'server')) {
    abort("`exam_options()` must be called in a server context.")
  }

  cache_data <- match.arg(cache_data)

  points_format_fun <- missing_arg()
  if (!missing(points_format)) {
    points_format_fun <- function (pts) {
      if (pts == 1) {
        return(sprintf(points_format[[1L]], pts))
      } else if (length(points_format) > 1L) {
        return(sprintf(points_format[[2L]], pts))
      } else {
        return(sprintf(points_format, pts))
      }
    }
  }

  .exam_data$set(auth_provider = auth_provider,
                 points_format = points_format_fun,
                 storage_provider = storage_provider,
                 exercise_evaluator = exercise_evaluator,
                 data_provider = cached_data_provider(data_provider %||% .exam_data$get('data_provider'),
                                                      cache_data %in% c('both', 'data')),
                 exercise_data_provider = cached_data_provider(exercise_data_provider %||%
                                                                 .exam_data$get('exercise_data_provider'),
                                                               cache_data %in% c('both', 'exercise_data')))
}

#' @importFrom digest digest
cached_data_provider <- function (fun, enabled) {
  if (enabled) {
    cache <- list()
    function (...) {
      hash <- digest(list(...))
      if (is.null(cache[[hash]])) {
        cache[[hash]] <- fun(...)
      }
      return(cache[[hash]])
    }
  } else {
    fun
  }
}

#' @importFrom rlang warn
get_rendering_env <- function (section, session) {
  # get a "random seed" to ensure data generation does not determine all other r code
  reset_seed <- sample.int(.Machine$integer.max, 1L)

  user <- get_current_user(session)
  data_env <- .exam_data$get('data_provider')(user, section)
  if (is.list(data_env)) {
    data_env <- list2env(data_env, parent = globalenv())
  } else if (is.environment(data_env)) {
    parent.env(data_env) <- globalenv()
  } else {
    warn("Data provider returns invalid environment.")
    data_env <- globalenv()
  }

  # new use the previously generated "random seed".
  set.seed(reset_seed)

  return(data_env)
}

#' @importFrom rlang warn
#' @importFrom withr local_preserve_seed
get_exercise_user_env <- function (exercise_label, session, user) {
  local_preserve_seed()

  if (missing(user)) {
    user <- get_current_user(session)
  }

  data_env <- .exam_data$get('exercise_data_provider')(user, exercise_label)
  if (is.list(data_env)) {
    data_env <- list2env(data_env, parent = emptyenv())
  } else if (is.environment(data_env)) {
    parent.env(data_env) <- emptyenv()
  } else {
    warn("Exercise data provider returns invalid environment.")
    data_env <- emptyenv()
  }

  return(data_env)
}

#' @importFrom shiny getDefaultReactiveDomain
get_current_user <- function (session) {
  if (missing(session)) {
    session <- getDefaultReactiveDomain()
  }
  session_env <- get_session_env(session)
  if (is.null(session_env$user)) {
    # authenticate current user
    session_env$user <- .exam_data$get('auth_provider')(session)
  }
  return(session_env$user)
}

#' Exercise Options
#'
#' Global options for exercise chunks. Each of these options can be overwritten in the individual exercise chunks by
#' specifying the `exercise.xyz` chunk option (`xyz` is one of the parameter names below).
#'
#' @param title title of the exercise. Default: _Coding question._
#' @param button label of the run exercise button. Default: _Run code._
#' @param button_context the bootstrap contextual class applied to the button. Default: _default_. See
#'  <https://getbootstrap.com/docs/3.3/css/#buttons-options> for a list of supported context classes.
#' @param timelimit time limit for the code to run (in seconds). Default: 5.
#' @param lines the minimum number of lines in the code editor. Default: 5.
#' @param autocomplete enable or disable auto-completion in the code editor. Default: `FALSE`.
#' @param df_print method used for printing data frames created by the user code. Default to use the same
#'  as the R-markdown document, but can be changed if needed. See argument `df_print` in
#'  [html_document()][rmarkdown::html_document()] for details.
#' @param setup the name of an R code chunk which is evaluated before the user code.
#' @param solution the name of an R code chunk which gives the solution to the exerise code chunk.
#'  This really only makes sense if set on a per-chunk basis.
#' @param checker a function (or the name of a function) which checks the R code in the exercise chunk.
#' @param points the default number of points an exercise is worth. Default: 1.
#' @param status_notrun status message if the exercise code has not yet been executed in this session. Default message:
#'   _Run the code by clicking the button in the top right corner of the exercise._
#' @param status_success status message if the exercise code has been run successfully and the output is shown below.
#'   Default message: _Code executed successfully._
#' @param status_error status message if the exercise code has resulted in an unknown error. Default message:
#'   _Cannot run the code._
#' @param status_invalid status message if the exercise code is invalid (currently only checked for R code). The
#'   message is followed by detailed information about the problem.
#'   Default message: _R code is invalid: _
#' @param status_empty status message if the exercise code has been run successfully, but did not produce any output.
#'   Default message: _Code executed successfully, but no output generated._
#' @param status_timeout status message if the exercise code takes too long to run. Default message:
#'   _Code takes too long to execute._
#'
#' @importFrom knitr opts_chunk
#' @importFrom rmarkdown shiny_prerendered_chunk
#' @export
exercise_options <- function (title, button, button_context, timelimit, lines, autocomplete, df_print, points,
                              setup, solution, checker,
                              status_notrun, status_invalid, status_error, status_success, status_empty,
                              status_timeout) {
  if (!is_missing(checker)) {
    checker <- match.fun(checker)
  }

  global_exercise_options <- list(
    title = title %||% opts_chunk$get('exercise.title') %||% "Coding question",
    button = button %||% opts_chunk$get('exercise.button') %||% "Run code",
    button_context = button_context %||% opts_chunk$get('exercise.button_context') %||% 'default',
    setup = setup %||% opts_chunk$get('exercise.setup') %||% NULL,
    solution = solution %||% opts_chunk$get('exercise.solution') %||% NULL,
    checker = checker %||% opts_chunk$get('exercise.checker') %||% NULL,
    lines = as.numeric(lines %||% opts_chunk$get('exercise.lines') %||% 5),
    df_print = df_print %||% opts_chunk$get('exercise.df_print') %||%
      opts_knit$get('rmarkdown.df_print') %||% 'default',
    timelimit = as.numeric(timelimit %||% opts_chunk$get('exercise.timelimit') %||% 5),
    autocomplete = isTRUE(autocomplete %||% opts_chunk$get('exercise.autocomplete') %||% TRUE),
    points = as.numeric(points %||% opts_chunk$get('exercise.points') %||% 1),
    status_notrun = status_notrun %||% opts_chunk$get('exercise.status_notrun') %||%
      "Run the code by clicking the button in the top right corner of the exercise.",
    status_invalid = status_invalid %||% opts_chunk$get('exercise.status_invalid') %||%
      "R code is invalid: ",
    status_error = status_error %||% opts_chunk$get('exercise.status_error') %||%
      "Cannot run the code.",
    status_success = status_success %||% opts_chunk$get('exercise.status_success') %||%
      "Code executed successfully.",
    status_empty = status_empty %||% opts_chunk$get('exercise.status_empty') %||%
      "Code executed successfully, but no output generated.",
    status_timeout = status_timeout %||% opts_chunk$get('exercise.status_timeout') %||%
      "Code takes too long to execute."
  )

  shiny_prerendered_chunk('server-start', sprintf('examinr:::register_global_exercise_options("%s")',
                                                  serialize_object(global_exercise_options)))

  names(global_exercise_options) <- paste('exercise', names(global_exercise_options), sep = '.')
  opts_chunk$set(global_exercise_options)
  opts_chunk$set(exercise_options_set = TRUE)
}

#' Exam Sections Options
#'
#' Control the behavior of the individual _sections_ of an exam.
#' Each exam contains one or more sections, which are shown progressively to the user.
#'
#' The sections options can be set in the metadata of the exam file and/or through the `sections_options()` function.
#' Options set via `sections_options()` and `section_specific_options()` take precedence over options set in
#' the metadata, if `.force=TRUE` (as by default).
#'
#' Sections are identified by the name.
#' For example, a section with title _# Section 1: Multiple Choice Questions_ would be identified by
#' `"Section 1: Multiple Choice Questions"`.
#' Note that pandoc heading identifiers (anything in `{}` at the end of the section title are omitted from the name.
#'
#' @param render render the sections on the server (`"server"`) or the client (`"client"`).
#'   If rendered on the server, the section content will only be sent to the client (i.e., the browser)
#'   when the section is displayed. This ensures users do not see the section content before navigating to the section.
#' @param order should be section order be fixed (`"fixed"`) or randomized (`"random"`) for each user.
#' @param fixed if `order="random"`, a character vector of sections (their names) which will be fixed the order.
#' @param next_button_label the label for the button at the end of a section. If `NA`, no button will be displayed.
#'   Default button label is _Next section_.
#' @param .force force the given options over already specified options. Default to `TRUE`.
#' @export
#'
#' @importFrom rlang is_missing
sections_options <- function (render, order, fixed, next_button_label, .force = TRUE) {
  .sections_data$set(render = pmatch_null(choose_one(render, .sections_data$get('render'), .force),
                                          c('server', 'client')),
                     order = pmatch_null(choose_one(order, .sections_data$get('order'), .force), c('random', 'fixed')),
                     next_button_label = enc2utf8(choose_one(next_button_label, .sections_data$get('next_button_label'),
                                                             .force) %||% 'Next section'))


  if (!is_missing(fixed)) {
    section_specifics <- .sections_data$get('specific')

    for (fixed_section in normalize_section_name(fixed)) {
      if (is.null(section_specifics[[fixed_section]])) {
        section_specifics[[fixed_section]] <- list()
      }
      section_specifics[[fixed_section]]$fixed <- choose_one(TRUE, section_specifics[[fixed_section]]$fixed, .force)
    }
    .sections_data$set(specific = section_specifics)
  }
}

#' @rdname sections_options
#'
#' @description
#' With `section_specific_options()`, options can be specified for individual sections identified via a section id.
#'
#' @param section name of the section for which to set specific options.
#' @param fix_order logical if the section should remain fixed in order.
#' @param next_button_context bootstrap 3 contextual class applied to the button. Takes precedence over the global
#'   specification in the [exam_document()] output format. See
#'   <https://getbootstrap.com/docs/3.3/css/#buttons-options> for a list of available classes.
#' @export
section_specific_options <- function (section, next_button_label, next_button_context, fix_order) {
  section <- normalize_section_name(section)
  section_specifics <- .sections_data$get('specific')

  if (is.null(section_specifics[[section]])) {
    new_specs <- list(list(fixed = fix_order %||% NULL, next_button_label = next_button_label %||% NULL,
                           next_button_context = next_button_context %||% NULL))
    names(new_specs) <- section
    .sections_data$append(specific = new_specs)
  } else {
    section_specifics[[section]]$next_button_label <- next_button_label %||%
      section_specifics[[section]]$next_button_label
    section_specifics[[section]]$fixed <- fix_order %||% section_specifics[[section]]$fixed
    section_specifics[[section]]$next_button_context <- next_button_context %||%
      section_specifics[[section]]$next_button_context

    .sections_data$set(specific = section_specifics)
  }
}

## Merge options from the document's metadata into the sections options.
## The current sections options takes precedence over the metadata
sections_options_from_metadata <- function (metadata) {
  sections_options(render = null_as_missing(metadata$render),
                   order = null_as_missing(metadata$order),
                   next_button_label = null_as_missing(metadata$next_button_label),
                   fixed = null_as_missing(metadata$fixed),
                   .force = FALSE)
}

#' @importFrom stringi stri_trim_both
#' @importFrom stringr str_detect str_starts fixed str_match str_replace_all
normalize_section_name <- function (section_title) {
  has_identifiers <- which(str_detect(section_title, '\\s*\\{.*\\}\\s*$'))
  if (length(has_identifiers) > 0L) {
    section_title[has_identifiers] <- str_match(section_title[has_identifiers], '^#?\\s*(.+)\\s*\\{.*\\}\\s*$')[, 2]
  }
  stri_trim_both(str_replace_all(tolower(section_title), '[^\\p{Alphabetic}\\p{Decimal_Number}]+', '-'),
                 pattern = '[^\\p{Wspace}\\-#]')
}
